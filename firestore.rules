
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper Functions
    function isSignedIn() {
      return request.auth != null && request.auth.uid != null;
    }

    function isSuperAdmin() {
      return isSignedIn() && request.auth.token.role == 'super_admin';
    }

    // Checks if the authenticated user is an admin of the specified organization.
    // orgIdFromPath: The organization ID from the document path.
    function isAdminOfOrg(orgIdFromPath) {
      return isSignedIn() && request.auth.token.role == 'admin' && request.auth.token.organizationId == orgIdFromPath;
    }

    // Checks if the authenticated user is a member (admin or collaborator) of the specified organization.
    // orgIdFromPath: The organization ID from the document path.
    function isMemberOfOrg(orgIdFromPath) {
      return isSignedIn() && request.auth.token.organizationId == orgIdFromPath && (request.auth.token.role == 'admin' || request.auth.token.role == 'collaborator');
    }

    // Checks if the authenticated user is the owner of the resource or self.
    function isSelf(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Users collection
    match /users/{userId} {
      allow read: if isSelf(userId) || 
                     (isAdminOfOrg(resource.data.organizationId)) || 
                     isSuperAdmin();
      // User creation should primarily be handled by Cloud Functions which have elevated privileges
      // or specific checks for who can create whom.
      allow create: if isSuperAdmin(); // Super admins can create users.
      // Allow self-updates and updates by admins of the same org or super admins.
      allow update: if isSelf(userId) || 
                       (isAdminOfOrg(resource.data.organizationId)) || 
                       isSuperAdmin();
      // Deleting user profiles should be a controlled process, likely via Cloud Functions.
      allow delete: if isSuperAdmin(); // Only super_admin can delete user profiles directly
    }

    // Organizations collection
    match /organizations/{orgId} {
      // Members of the org and super admins can read the org document.
      allow get: if isMemberOfOrg(orgId) || isSuperAdmin();
      // Only super admins can list all organizations.
      allow list: if isSuperAdmin();
      // Only super admins can create, update, or delete organizations.
      allow create, update, delete: if isSuperAdmin();

      // Default read access for members within their organization's subcollections
      match /{subcollection}/{docId} {
        allow read: if isMemberOfOrg(orgId); // Covers get and list
      }

      // --- Specific rules for subcollections to override or add write permissions ---

      match /tasks/{taskId} {
        // read is covered by the default rule above.
        allow create, update, delete: if isAdminOfOrg(orgId);
      }

      match /roles/{roleId} {
        // read is covered by the default rule above.
        allow create, update, delete: if isAdminOfOrg(orgId);
      }

      match /departments/{deptId} {
        // read is covered by the default rule above.
        allow create, update, delete: if isAdminOfOrg(orgId);
      }
      
      match /appSettings/{settingsDoc} {
        // read is covered by the default rule above.
        allow create, update: if isAdminOfOrg(orgId);
      }

      match /rankingManagement/{rankingDoc} {
        // read is covered by the default rule above.
        allow create, update: if isAdminOfOrg(orgId);
      }

      match /challenges/{challengeId} {
        // read is covered by the default rule above.
        allow create, update, delete: if isAdminOfOrg(orgId);
      }

      match /challengeParticipations/{partId} {
        // Read for specific participation doc: Admin of org OR self
        allow get: if isMemberOfOrg(orgId) && (isAdminOfOrg(orgId) || request.auth.uid == resource.data.employeeId);
        // List for participations: Members of org (frontend query must filter by employeeId for collaborators)
        // Covered by generic subcollection read rule.

        // Employee can create their own participation
        allow create: if isMemberOfOrg(orgId) && 
                         request.resource.data.employeeId == request.auth.uid &&
                         request.resource.data.organizationId == orgId;
        // Employee can update (submit) their own participation if status is 'accepted'
        // Admin can update (evaluate) any participation
        allow update: if isMemberOfOrg(orgId) && 
                         ( (isSelf(resource.data.employeeId) && resource.data.status == 'accepted' && request.resource.data.status == 'submitted') || 
                           isAdminOfOrg(orgId) );
        allow delete: if false; // Generally, participations are not deleted directly
      }

      match /evaluations/{evalId} {
        // Read for specific evaluation doc: Admin of org OR self
        allow get: if isMemberOfOrg(orgId) && (isAdminOfOrg(orgId) || request.auth.uid == resource.data.employeeId);
        // List for evaluations: Members of org (frontend query for collaborator dashboard lists all then filters - this is covered by generic read)
        // Covered by generic subcollection read rule.

        // Only admins can create/update evaluations
        allow create, update: if isAdminOfOrg(orgId);
        allow delete: if false; // Evaluations are generally not deleted
      }

      match /awardHistory/{historyId} {
        // read is covered by default rule
        allow create, update, delete: if isAdminOfOrg(orgId);
      }
    }

    // Global collections
    match /awards/{awardId} { // Awards managed by super_admin
      allow read, list: if isSignedIn();
      allow create, update, delete: if isSuperAdmin();
    }

    match /plans/{planId} { // Plans managed by super_admin
      allow read, list: if isSignedIn();
      allow create, update, delete: if isSuperAdmin();
    }
  }
}
